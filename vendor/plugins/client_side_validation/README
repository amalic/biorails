Client Side Validation
======================

Version 0.2.5, 2006-12-28

Requires Validation Reflection plugin.

This plugin is only a tool, it leaves some work for you to do.
The plugin happily handles the validation part, but it is your
job to handle the notification.

To make the validator available in your views, its script file
has to be included. This happens automatically when you issue

 <%= javascript_include_tag :defaults %>

in the <head> element of the view itself or the enclosing layout.
As you probably want validation for a specific locale, you also
need to include the requisite script for that

 <%= javascript_include_tag 'validators-en' %>

See below for a few more details on localization.

Then, to activate the validator for each form on the page which 
has the class "validated" (<form class="validated">...</form>)
add the following line to public/javascripts/application.js:

  Form.Validator.installForAllValidatedForms();

If any of the validated forms' input elements are or become
invalid, they are marked with the class "invalid". If you have 
something like this

 .invalid {
   border: 1px solid #f00;
 }

somewhere in your stylesheet(s), invalid fields will be marked with
a read border.

Currently, validation is supported for 

* validates_presence_of
* validates_length_of
* validates_numericality_of
* validates_inclusion_of
* validates_format_of - as far as regular expressions are matched the 
  same in Ruby and JavaScript


== Localization

Without further doing, the validator is not set up to handle any
specific locale. For instance, dates assumed to be in ISO 8601 format,
say 2006-08-13. To make the validator handle a specific locale, you
need to load a JavaScript file with validators for that locale. Put

 <%= javascript_include_tag 'validators-en' %>

as the last javascript_include_tag in your layout. Currently, there
are validators-en and validators-de. And all they do is handle the
different date formats.


== Custom Checking

If you need client-side validations that can't be expressed with these
means, you'll have to write a validation function yourself.
Again in application.js

 Object.extend(Form.Validator.Validators, {
   very_special: function(value) {
     // Leave the check if there actually is a value to the
     // validation function set up for :validates_presence_of.
     if (!this.value) {
       return true;
     }
     // Do the ckecking...
     return true;
   }
 });
 
Then, in a view where a text field (or whatever it is) needs to be
subject to this very special test

 <%= text_field :object, :attribute, :class => 'very_special' %>

That's it.

=== Complicated Checks

The declarative wiring of validation functions can be used for 
functions that need to take into account the values of multiple
input elements. Writing these functions is a bit tricky. If you
really need such a thing, look at the code for 
<tt>Form.Validator.Validators#exactly</tt> and
<tt>Form.Validator.Validators#different</tt>.


== Notifying Users of Validation Results

 Form.Validator.install('person_form', {
   onElementStatusChange: {
     person_last_name: function(isValid) {
       if (!isValid) alert(this.value + " is not a valid last name.");
     },
   },
   onFormStatusChange: function(isValid) {
     if (!isValid) alert("Your form is not valid!");
   }
 });

If you provide your own +onElementStatusChange+ function for reporting
a status change, this overrides the default behavior of adding/removing
the "invalid" class to the input element. You can explicitly invoke
that behavior like this

     person_last_name: function(isValid) {
       Form.Validator.switchClassNameInvalid(this, isValid);
       if (!isValid) alert(this.value + " is not a valid last name.");
     },

Obviously, just popping up an alert box or putting a border around an
element isn't very user friendly. Especially so for a validator like 
this that checks continuously. Therefore you need to come up with a
way to notify your users of errors in a way that meshes well with the
rest of the application.


Currently, there is no way to find out which specific validation failed
for a given input element. As validations don't have any identifiert
I'm hard pressed for a good idea.


== Changes

=== 0.2.5
* Add and use element.__getValue() to get at the value of a validated
  element.
* Don't automatically reflect conditional validations to JavaScript, i.e.
  validations that have a :if => proc { ... } test.
=== 0.2.4
* Moved lib files into subfolder boiler_plate.
=== 0.2.3
* Validator: Added a missing $() around an element argument. 
=== 0.2.2
* Compatibility with Internet Explorer 6 and 7. Apparently they don't
  understand someElement.hasClassName('classname').

Copyright (c) 2006, Michael Schuerig, michael@schuerig.de
